{".parseHeader throw if not a string given":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":1,"str":"(t) => {\n  t.throws(() => parseHeader(123), TypeError);\n  t.throws(() => parseHeader(123), /expect `header` to be non empty string/);\n  t.throws(() => parseHeader(''), /expect `header` to be non empty string/);\n}","title":".parseHeader throw if not a string given"},".parseHeader throw when invalid conventional commits":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":2,"str":"(t) => {\n  function fixture() {\n    parseHeader('fix bar qux');\n  }\n  t.throws(fixture, Error);\n  t.throws(fixture, /<type>\\[optional scope\\]: <description>/);\n}","title":".parseHeader throw when invalid conventional commits"},".parseHeader NOT throw when header is valid by conventional commits":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":3,"str":"(t) => {\n  const one = parseHeader('fix: zzz qux');\n  const two = parseHeader('fix(cli): aaaa qux');\n  const res = parseHeader('fix(cli): qqqqq qux\\n\\nSome awesome body');\n\n  t.ok(isObject(one));\n  t.ok(isObject(two));\n  t.ok(isObject(res));\n}","title":".parseHeader NOT throw when header is valid by conventional commits"},".parseHeader correctly header string without scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":4,"str":"(t) => {\n  const result = parseHeader('fix: bar qux');\n\n  t.deepStrictEqual(result, { type: 'fix', scope: null, subject: 'bar qux' });\n}","title":".parseHeader correctly header string without scope"},".parseHeader header string with scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":5,"str":"(t) => {\n  t.deepStrictEqual(parseHeader('fix(cli): bar qux'), {\n    type: 'fix',\n    scope: 'cli',\n    subject: 'bar qux',\n  });\n}","title":".parseHeader header string with scope"}}