{"should be okey with multiline body and without scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":1,"str":"(t) => {\n  const msg = `feat: foo bar baz\n\nSome multiline body\nAlleluah\n\nSo there is some updated things\nfixes #34\nresolves #225\n`;\n\n  const commit = parse(msg, plugins);\n  // => {\n  //   header: {\n  //     type: 'feat',\n  //     scope: undefined,\n  //     subject: 'foo bar baz',\n  //     toString: [Function: toString],\n  //   },\n  //   body: 'Some multiline body\\nAlleluah',\n  //   footer: 'So there is some updated things\\nfixes #34\\nresolves #225\\n',\n  //   increment: 'minor',\n  //   isBreaking: false,\n  // }\n\n  t.strictEqual(typeof commit, 'object');\n  t.strictEqual(commit.increment, 'minor');\n  t.strictEqual(commit.isBreaking, false);\n  t.strictEqual(commit.header.type, 'feat');\n  t.ok(!commit.header.scope, 'commit.header.scope should be falsey');\n  t.strictEqual(commit.header.subject, 'foo bar baz');\n  t.strictEqual(typeof commit.header.toString, 'function');\n  t.strictEqual(commit.header.toString(), 'feat: foo bar baz');\n  t.strictEqual(commit.body, 'Some multiline body\\nAlleluah');\n  t.strictEqual(\n    commit.footer,\n    'So there is some updated things\\nfixes #34\\nresolves #225',\n  );\n}","title":"should be okey with multiline body and without scope"},"should have empty body but contain footer":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":2,"str":"(t) => {\n  const msg = `fix: some non-breaking update\n\nOnly footer\nfixes #33\n`;\n  const commit = parse(msg, plugins);\n\n  t.ok(!commit.body, 'should have falsey value `body` property');\n  t.ok(!commit.header.scope, 'commit.header.scope should be falsey');\n  t.strictEqual(commit.footer, 'Only footer\\nfixes #33');\n  t.strictEqual(commit.increment, 'patch');\n  t.strictEqual(commit.header.toString(), 'fix: some non-breaking update');\n}","title":"should have empty body but contain footer"},"should have empty body and footer but scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":3,"str":"(t) => {\n  const str = 'break(critical): some breaking with no body';\n  const commit = parse(str, plugins);\n\n  t.ok(!commit.body, 'should have falsey value `body` property');\n  t.ok(!commit.footer, 'commit.footer should be falsey');\n  t.strictEqual(commit.isBreaking, true);\n  t.strictEqual(commit.increment, 'major');\n  t.strictEqual(commit.header.scope, 'critical');\n  t.strictEqual(commit.header.toString(), str);\n}","title":"should have empty body and footer but scope"},"should support and collect all mentions from anywehere":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":4,"str":"(t) => {\n  const msg = `feat(crit): thanks to @foobar for this release\n\nAlso to @barby!\n\nthanks to @hix!\nresolves #123\n`;\n\n  const commit = parse(msg, plugins);\n\n  t.strictEqual(Array.isArray(commit.mentions), true);\n  t.strictEqual(commit.mentions.length, 3);\n\n  t.strictEqual(commit.mentions[0].handle, '@foobar');\n  t.strictEqual(commit.mentions[0].mention, 'foobar');\n  t.strictEqual(commit.mentions[1].handle, '@barby');\n  t.strictEqual(commit.mentions[1].mention, 'barby');\n  t.strictEqual(commit.mentions[2].handle, '@hix');\n  t.strictEqual(commit.mentions[2].mention, 'hix');\n\n  t.strictEqual(commit.header.scope, 'crit');\n  t.strictEqual(commit.increment, 'minor');\n}","title":"should support and collect all mentions from anywehere"},"should .parse throw if no string as first argument":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":5,"str":"(t) => {\n  t.throws(() => {\n    parse(123);\n  }, /expect `commitMessage` to be string/);\n}","title":"should .parse throw if no string as first argument"},"should .parse throw for invalid commit convention message":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":6,"str":"(t) => {\n  t.throws(() => parse('foo bar baz'), /invalid commit message/);\n}","title":"should .parse throw for invalid commit convention message"},"do not treat BREAKING CHANGE as major when not at the beginning":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":7,"str":"(t) => {\n  const commitMessage = 'fix(abc): foo bar BREAKING CHANGE here is not valid';\n  const commit = parse(commitMessage, plugins);\n\n  t.strictEqual(commit.header.type, 'fix');\n  t.strictEqual(commit.header.scope, 'abc');\n  t.strictEqual(\n    commit.header.subject,\n    'foo bar BREAKING CHANGE here is not valid',\n  );\n  t.strictEqual(commit.increment, 'patch');\n}","title":"do not treat BREAKING CHANGE as major when not at the beginning"},"treat `BREAKINGs+CHANGE:s+` as major even if type is `fix`":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":8,"str":"(t) => {\n  const msg = `fix: huge bug is resolved\n\nBREAKING CHANGE: really big refactor\n\nresolves #2137\n`;\n\n  const commit = parse(msg, mappers.increment);\n\n  t.strictEqual(commit.isBreaking, true);\n  t.strictEqual(commit.increment, 'major');\n  t.strictEqual(commit.body, 'BREAKING CHANGE: really big refactor');\n  t.strictEqual(commit.footer, 'resolves #2137');\n  t.strictEqual(commit.header.type, 'fix');\n  t.strictEqual(commit.header.toString(), 'fix: huge bug is resolved');\n}","title":"treat `BREAKINGs+CHANGE:s+` as major even if type is `fix`"}}