{"should be okey with multiline body and without scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":1,"str":"t => {\n  const msg = `feat: foo bar baz\n\nSome multiline body\nAlleluah\n\nSo there is some updated things\nfixes #34\nresolves #225\n`;\n  const commit = (0, _index.parse)(msg); // => {\n  //   header: {\n  //     type: 'feat',\n  //     scope: undefined,\n  //     subject: 'foo bar baz',\n  //     toString: [Function: toString],\n  //   },\n  //   body: 'Some multiline body\\nAlleluah',\n  //   footer: 'So there is some updated things\\nfixes #34\\nresolves #225\\n',\n  //   increment: 'minor',\n  //   isBreaking: false,\n  // }\n\n  t.strictEqual(typeof commit, 'object');\n  t.ok(commit.mentions);\n  t.strictEqual(commit.increment, 'minor');\n  t.strictEqual(commit.isBreaking, false);\n  t.strictEqual(commit.header.type, 'feat');\n  t.ok(!commit.header.scope, 'commit.header.scope should be falsey');\n  t.strictEqual(commit.header.subject, 'foo bar baz');\n  t.strictEqual(typeof commit.header.toString, 'function');\n  t.strictEqual(commit.header.toString(), 'feat: foo bar baz');\n  t.strictEqual(commit.body, 'Some multiline body\\nAlleluah');\n  t.strictEqual(commit.footer, 'So there is some updated things\\nfixes #34\\nresolves #225');\n}","title":"should be okey with multiline body and without scope"},"should have empty body but contain footer":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":2,"str":"t => {\n  const msg = `fix: some non-breaking update\n\nOnly footer\nfixes #33\n`;\n  const commit = (0, _index.parse)(msg, _index.mappers.increment);\n  t.ok(!commit.body, 'should have falsey value `body` property');\n  t.ok(!commit.header.scope, 'commit.header.scope should be falsey');\n  t.strictEqual(commit.footer, 'Only footer\\nfixes #33');\n  t.strictEqual(commit.increment, 'patch');\n  t.strictEqual(commit.header.toString(), 'fix: some non-breaking update');\n}","title":"should have empty body but contain footer"},"should have empty body and footer but scope":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":3,"str":"t => {\n  const str = 'break(critical): some breaking with no body';\n  const commit = (0, _index.parse)(str, _index.mappers.increment);\n  t.ok(!commit.body, 'should have falsey value `body` property');\n  t.ok(!commit.footer, 'commit.footer should be falsey');\n  t.strictEqual(commit.isBreaking, true);\n  t.strictEqual(commit.increment, 'major');\n  t.strictEqual(commit.header.scope, 'critical');\n  t.strictEqual(commit.header.toString(), str);\n}","title":"should have empty body and footer but scope"},"should support and collect all mentions from anywehere":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":4,"str":"t => {\n  const msg = `feat(crit): thanks to @foobar for this release\n\nAlso to @barby!\n\nthanks to @hix!\nresolves #123\n`;\n  const commit = (0, _index.parse)(msg, _index.plugins);\n  t.strictEqual(Array.isArray(commit.mentions), true); // strong type sometimes sucks?\n\n  const mentions = commit.mentions || [];\n  t.strictEqual(mentions.length, 3);\n  t.strictEqual(mentions[0].handle, '@foobar');\n  t.strictEqual(mentions[0].mention, 'foobar');\n  t.strictEqual(mentions[1].handle, '@barby');\n  t.strictEqual(mentions[1].mention, 'barby');\n  t.strictEqual(mentions[2].handle, '@hix');\n  t.strictEqual(mentions[2].mention, 'hix');\n  t.strictEqual(commit.header.scope, 'crit');\n  t.strictEqual(commit.increment, 'minor');\n}","title":"should support and collect all mentions from anywehere"},"should .parse throw if no string as first argument":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":5,"str":"t => {\n  t.throws(() => {\n    // @ts-ignore\n    (0, _index.parse)(123);\n  }, /expect `commitMessage` to be string/);\n}","title":"should .parse throw if no string as first argument"},"should .parse throw for invalid commit convention message":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":6,"str":"t => {\n  t.throws(() => (0, _index.parse)('foo bar baz'), /invalid commit message/);\n}","title":"should .parse throw for invalid commit convention message"},"do not treat BREAKING CHANGE as major when not at the beginning":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":7,"str":"t => {\n  const commitMessage = 'fix(abc): foo bar BREAKING CHANGE here is not valid';\n  const commit = (0, _index.parse)(commitMessage, _index.mappers.increment);\n  t.strictEqual(commit.header.type, 'fix');\n  t.strictEqual(commit.header.scope, 'abc');\n  t.strictEqual(commit.header.subject, 'foo bar BREAKING CHANGE here is not valid');\n  t.strictEqual(commit.increment, 'patch');\n}","title":"do not treat BREAKING CHANGE as major when not at the beginning"},"treat `BREAKINGs+CHANGE:s+` as major even if type is `fix`":{"skip":false,"todo":false,"run":false,"isPending":false,"isRejected":false,"isFulfilled":true,"id":8,"str":"t => {\n  const msg = `fix: huge bug is resolved\n\nBREAKING CHANGE: really big refactor\n\nresolves #2137\n`;\n  const commit = (0, _index.parse)(msg, _index.mappers.increment);\n  t.strictEqual(commit.isBreaking, true);\n  t.strictEqual(commit.increment, 'major');\n  t.strictEqual(commit.body, 'BREAKING CHANGE: really big refactor');\n  t.strictEqual(commit.footer, 'resolves #2137');\n  t.strictEqual(commit.header.type, 'fix');\n  t.strictEqual(commit.header.toString(), 'fix: huge bug is resolved');\n}","title":"treat `BREAKINGs+CHANGE:s+` as major even if type is `fix`"}}